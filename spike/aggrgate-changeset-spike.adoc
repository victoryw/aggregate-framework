= aggregate-frameworks 聚合根变更集合调研
:hardbreaks-option:
:imagesdir: ./images



== 目标——实现一个自动的工作单元控制器(unit of work controller)
在 DDD 战术设计落地为代码进行持久化过程中，经常遇到一个问题:
在使用关系型数据库的时候，如何获得聚合根内部的变化（增删改查）以进行持久化？

这个问题正是 Martin Fowler 在 《企业应用架构模式》中提到的将内存对象映射到关系型数据库时的行为问题。

这个问题在编程实践过程中，我通常见过3种解决方法：

- 使用 JPA、EntityFramework等 内置了 change set 能力的 ORM 框架；
- 将 repository 注入到领域模型中，使得领域对象负责数据库的存取过程，也就是 《企业应用架构模式》提到的活动记录模式
- 在领域服务中操作领域对象，并调用 repository 进行持久化操作

这三种方法都可以解决 "如何获得聚合根内部的变化（增删改查）以进行持久化" 这个问题。只是各有缺点：

- 使用 ORM 框架：国内的团队更喜欢使用轻量级的mapper，以获得更好地 进行SQL审计、性能调优等
- 使用活动记录模式：一方面与 Eric 提出的 通过 repository 来统一存取 聚合根持有的对象相违背，实现领域逻辑的过程中需要考虑领域对象和数据库表关联关系；另一方面，如 Martin Fowler 在 《企业应用架构模式》所说使用活动记录模式后通过设计模式来实现更灵活的领域逻辑的能力受限
- 领域服务中操作领域对象：这个打破了聚合根内聚逻辑的基本原则，导致了领域对象成为了常说的贫血模型，使得业务行为和业务数据不能内聚在领域对象中，而是分散在了领域服务和领域对象中

Martin Fowler 在 《企业应用架构模式》提到了通过使用 工作单元 ("Unit of Work") 来跟踪所有从数据库读取的对象以及所有以任何形式修改过的对象，从而在聚合根持久化时，从工作单元 ("Unit of Work")获得聚合根内部的变化。

将对象变化注册到工作单元 ("Unit of Work")有3种方式：

1. 调用者注册的方式（caller registration）的方式：如果调用者改变了某个调用者需要负责将这个对象的变化注册到工作单元中；
2. 对象注册方式（object registration）：如果对象被修改，那么这个对象需要负责将自己的变化注册到工作单元中；
3. 工作单元控制器（unit of work controller）的方式：工作单元在读取对象时候，记录这个对象的副本；并在提交持久化时，负责找到变化的对象。

这三种方式各有利弊，只是1，2种方法需要开发者在实现业务逻辑，同时做好对象变化注册到工作单元，需要开发者小心翼翼（从具体场景和测试两方面把控实践也是可以解决的）。第三种方法更容易以框架的方式实现。

总而言之，这里的目标是实现一个自动的工作单元控制器(unit of work controller)的低侵入框架，以当更新\删除聚合根时可以得到：

* 聚合根内所有变化的对象，子对象，子子对象
* 聚合根内所有被删除的对象，子对象，子子对象


== 调查范围

== 调查内容

=== 模块内的包的依赖关系


image::target_scope.png[]

=== org.aggregateframework.entity

=== org.aggregateframework.dao

=== org.aggregateframework.session

=== org.aggregateframework.repository

== 改造思路

=== 与期望的差异

==== 可以复用的地方

==== 需要改造的地方

=== 改造计划